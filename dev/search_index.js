var documenterSearchIndex = {"docs":
[{"location":"source/#QuantumCircuits","page":"Public API","title":"QuantumCircuits","text":"","category":"section"},{"location":"source/","page":"Public API","title":"Public API","text":"","category":"page"},{"location":"source/","page":"Public API","title":"Public API","text":"Modules = [QuantumCircuits]\nPages = [\"QuantumCircuits.jl\", \"RandomMatrices.jl\", \"QCircuitUtils.jl\", \"QCircuitDynamics.jl\"]","category":"page"},{"location":"source/#QuantumCircuits.greet-Tuple{}","page":"Public API","title":"QuantumCircuits.greet","text":"greet() = print(\"Hello QuantumCircuits!\")\n\n\n\n\n\n","category":"method"},{"location":"source/#QuantumCircuits.haar_unitary-Tuple{Int64}","page":"Public API","title":"QuantumCircuits.haar_unitary","text":"haar_unitary(n::Int) :: Matrix{ComplexF64}\n\nGenerate a random Haar unitary matrix of size n x n.\n\nArguments\n\nn::Int: The size of the matrix.\n\nReturns\n\nMatrix{ComplexF64}: The generated Haar unitary matrix.\n\n\n\n\n\n","category":"method"},{"location":"source/#QuantumCircuits.random_hermitian-Tuple{Int64}","page":"Public API","title":"QuantumCircuits.random_hermitian","text":"random_hermitian(n::Int) :: Matrix{ComplexF64}\n\nGenerate a random Hermitian matrix of size n x n.\n\nArguments\n\nn::Int: The size of the matrix.\n\nReturns\n\nMatrix{ComplexF64}: The generated Hermitian matrix.\n\n\n\n\n\n","category":"method"},{"location":"source/#QuantumCircuits.fidelity-Tuple{Vector{ComplexF64}, Vector{ComplexF64}}","page":"Public API","title":"QuantumCircuits.fidelity","text":"fidelity(v1::Vector{ComplexF64}, v2::Vector{ComplexF64}) :: Float64\n\nCompute the fidelity between two complex vectors v1 and v2.\n\nThe fidelity is defined as the squared absolute value of the dot product between v1 and v2.\n\nArguments\n\nv1::Vector{ComplexF64}: The first complex vector.\nv2::Vector{ComplexF64}: The second complex vector.\n\nReturns\n\nFloat64: The fidelity between v1 and v2.\n\n\n\n\n\n","category":"method"},{"location":"source/#QuantumCircuits.is_valid_statevector-Tuple{Vector{ComplexF64}}","page":"Public API","title":"QuantumCircuits.is_valid_statevector","text":"is_valid_statevector(v::Vector{ComplexF64}) :: Bool\n\nCheck if the given vector v is a valid state vector.\n\nA valid state vector is a vector of complex numbers whose Euclidean norm is approximately equal to 1.\n\nArguments\n\nv::Vector{ComplexF64}: The vector to be checked.\n\nReturns\n\ntrue if the vector is a valid state vector, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"source/#QuantumCircuits.post_measurement_state-Tuple{Vector{ComplexF64}, Matrix{ComplexF64}}","page":"Public API","title":"QuantumCircuits.post_measurement_state","text":"post_measurement_state(state::Vector{ComplexF64}, Π::Matrix{ComplexF64})::Vector{ComplexF64}\n\nPost-processes the state vector after a measurement is performed.\n\nArguments\n\nstate::Vector{ComplexF64}: The input state vector.\nΠ::Matrix{ComplexF64}: The measurement operator.\n\nReturns\n\nVector{ComplexF64}: The post-measurement state vector.\n\nThrows\n\nArgumentError: If the probability of getting the measurement outcome is zero.\n\n\n\n\n\n","category":"method"},{"location":"source/#QuantumCircuits.prob-Tuple{Vector{ComplexF64}, Matrix{ComplexF64}}","page":"Public API","title":"QuantumCircuits.prob","text":"prob(state::Vector{ComplexF64}, Π::Matrix{ComplexF64})::Float64\n\nCompute the probability of measuring a quantum state state given the measurement operator Π.\n\nArguments\n\nstate::Vector{ComplexF64}: The quantum state vector.\nΠ::Matrix{ComplexF64}: The measurement operator.\n\nReturns\n\nFloat64: The probability of measuring the state.\n\n\n\n\n\n","category":"method"},{"location":"source/#QuantumCircuits.projective_measurement_operator-Tuple{Int64, Char, Int64}","page":"Public API","title":"QuantumCircuits.projective_measurement_operator","text":"projective_measurement_operator(n::Int, basis::Char, index::Int)::Matrix{ComplexF64}\n\nConstructs the projective measurement operator for a quantum circuit.\n\nArguments\n\nn::Int: The number of qubits in the quantum circuit.\nbasis::Char: The measurement basis. Must be either 'z' or 'x'.\nindex::Int: The index of the qubit to be measured.\n\nReturns\n\nA matrix representing the projective measurement operator.\n\n\n\n\n\n","category":"method"},{"location":"source/#QuantumCircuits.random_statevector-Tuple{Int64}","page":"Public API","title":"QuantumCircuits.random_statevector","text":"random_statevector(n::Int) :: Vector{ComplexF64}\n\nGenerate a random state vector of length 2^n.\n\nArguments\n\nn::Int: The number of qubits.\n\nReturns\n\nv::Vector{ComplexF64}: The random state vector.\n\n\n\n\n\n","category":"method"},{"location":"source/#QuantumCircuits.zero_state-Tuple{Int64}","page":"Public API","title":"QuantumCircuits.zero_state","text":"zero_state(n::Int) :: Vector{ComplexF64}\n\nInitialize the state vector for a quantum circuit with n qubits.\n\nArguments\n\nn::Int: The number of qubits in the quantum circuit.\n\nReturns\n\nv::Vector{ComplexF64}: The initialized state vector.\n\n\n\n\n\n","category":"method"},{"location":"source/#QuantumCircuits.unitary_circuit_evolution-Tuple{Vector{ComplexF64}, Any}","page":"Public API","title":"QuantumCircuits.unitary_circuit_evolution","text":"unitary_circuit_evolution(state::Vector{ComplexF64}, no_of_generations)\n\nThis function performs the evolution of a quantum state through a unitary circuit.\n\nArguments\n\nstate::Vector{ComplexF64}: The initial quantum state represented as a vector of complex numbers.\nno_of_generations: The number of generations or iterations of the circuit evolution.\n\nReturns\n\nfinal_state::Vector{ComplexF64}: The final quantum state after the specified number of generations.\n\n\n\n\n\n","category":"method"},{"location":"source/#QuantumCircuits.unitary_circuit_evolution_with_measurement-Tuple{Vector{ComplexF64}, Any}","page":"Public API","title":"QuantumCircuits.unitary_circuit_evolution_with_measurement","text":"unitary_circuit_evolution_with_measurement(state::Vector{ComplexF64}, no_of_generations)\n\nThis function performs the evolution of a quantum circuit with measurements.\n\nArguments\n\nstate::Vector{ComplexF64}: The initial state of the quantum circuit.\nno_of_generations: The number of generations for which the circuit should evolve.\n\nReturns\n\nfinal_state::Vector{ComplexF64}: The final state of the quantum circuit after evolution.\n\nThrows\n\nArgumentError: If the number of qubits is not even or if the number of qubits is less than m.\n\nDescription\n\nThis function evolves a quantum circuit with measurements for a given number of generations.\nThe circuit evolution is performed using unitary matrices generated from the Haar measure.\nIn each generation, the circuit is evolved using either odd or even generation unitary matrices.\nAfter each evolution step, a measurement is performed on a randomly chosen qubit using either the z or x basis.\nThe measurement outcome is used to update the state of the circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/randMatrix/#Random-Matrices-Generation","page":"Random Matrices","title":"Random Matrices Generation","text":"","category":"section"},{"location":"man/randMatrix/","page":"Random Matrices","title":"Random Matrices","text":"This module provides functions to generate random matrices. ","category":"page"},{"location":"man/randMatrix/#Random-Unitary","page":"Random Matrices","title":"Random Unitary","text":"","category":"section"},{"location":"man/randMatrix/","page":"Random Matrices","title":"Random Matrices","text":"haar_unitary","category":"page"},{"location":"man/randMatrix/#QuantumCircuits.haar_unitary","page":"Random Matrices","title":"QuantumCircuits.haar_unitary","text":"haar_unitary(n::Int) :: Matrix{ComplexF64}\n\nGenerate a random Haar unitary matrix of size n x n.\n\nArguments\n\nn::Int: The size of the matrix.\n\nReturns\n\nMatrix{ComplexF64}: The generated Haar unitary matrix.\n\n\n\n\n\n","category":"function"},{"location":"man/randMatrix/","page":"Random Matrices","title":"Random Matrices","text":"using QuantumCircuits\nhaar_unitary(2)","category":"page"},{"location":"man/randMatrix/#Random-Hermitian","page":"Random Matrices","title":"Random Hermitian","text":"","category":"section"},{"location":"man/randMatrix/","page":"Random Matrices","title":"Random Matrices","text":"random_hermitian","category":"page"},{"location":"man/randMatrix/#QuantumCircuits.random_hermitian","page":"Random Matrices","title":"QuantumCircuits.random_hermitian","text":"random_hermitian(n::Int) :: Matrix{ComplexF64}\n\nGenerate a random Hermitian matrix of size n x n.\n\nArguments\n\nn::Int: The size of the matrix.\n\nReturns\n\nMatrix{ComplexF64}: The generated Hermitian matrix.\n\n\n\n\n\n","category":"function"},{"location":"man/randMatrix/","page":"Random Matrices","title":"Random Matrices","text":"using QuantumCircuits\nrandom_hermitian(2)","category":"page"},{"location":"man/circuitUtils/#Quantum-Circuit-Utils","page":"Circuit Utilities","title":"Quantum Circuit Utils","text":"","category":"section"},{"location":"man/circuitUtils/","page":"Circuit Utilities","title":"Circuit Utilities","text":"using QuantumCircuits # hide\nusing QuantumInformation: ket # hide\n\nu = ket(1, 2); # |0⟩\nd = ket(2, 2); # |1⟩\n\nu, d","category":"page"},{"location":"man/circuitUtils/#State-Vectors-Utility","page":"Circuit Utilities","title":"State Vectors Utility","text":"","category":"section"},{"location":"man/circuitUtils/","page":"Circuit Utilities","title":"Circuit Utilities","text":"random_statevector","category":"page"},{"location":"man/circuitUtils/#QuantumCircuits.random_statevector","page":"Circuit Utilities","title":"QuantumCircuits.random_statevector","text":"random_statevector(n::Int) :: Vector{ComplexF64}\n\nGenerate a random state vector of length 2^n.\n\nArguments\n\nn::Int: The number of qubits.\n\nReturns\n\nv::Vector{ComplexF64}: The random state vector.\n\n\n\n\n\n","category":"function"},{"location":"man/circuitUtils/","page":"Circuit Utilities","title":"Circuit Utilities","text":"is_valid_statevector","category":"page"},{"location":"man/circuitUtils/#QuantumCircuits.is_valid_statevector","page":"Circuit Utilities","title":"QuantumCircuits.is_valid_statevector","text":"is_valid_statevector(v::Vector{ComplexF64}) :: Bool\n\nCheck if the given vector v is a valid state vector.\n\nA valid state vector is a vector of complex numbers whose Euclidean norm is approximately equal to 1.\n\nArguments\n\nv::Vector{ComplexF64}: The vector to be checked.\n\nReturns\n\ntrue if the vector is a valid state vector, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"man/circuitUtils/","page":"Circuit Utilities","title":"Circuit Utilities","text":"zero_state","category":"page"},{"location":"man/circuitUtils/#QuantumCircuits.zero_state","page":"Circuit Utilities","title":"QuantumCircuits.zero_state","text":"zero_state(n::Int) :: Vector{ComplexF64}\n\nInitialize the state vector for a quantum circuit with n qubits.\n\nArguments\n\nn::Int: The number of qubits in the quantum circuit.\n\nReturns\n\nv::Vector{ComplexF64}: The initialized state vector.\n\n\n\n\n\n","category":"function"},{"location":"man/circuitUtils/#Quantum-Information-Quantities","page":"Circuit Utilities","title":"Quantum Information Quantities","text":"","category":"section"},{"location":"man/circuitUtils/#Fidelity","page":"Circuit Utilities","title":"Fidelity","text":"","category":"section"},{"location":"man/circuitUtils/","page":"Circuit Utilities","title":"Circuit Utilities","text":"tip: Fidelity\nThe fidelity between two states is defined as the square of the overlap between the two states.F(psi phi) = langle psi  phi rangle^2","category":"page"},{"location":"man/circuitUtils/","page":"Circuit Utilities","title":"Circuit Utilities","text":"fidelity","category":"page"},{"location":"man/circuitUtils/#QuantumCircuits.fidelity","page":"Circuit Utilities","title":"QuantumCircuits.fidelity","text":"fidelity(v1::Vector{ComplexF64}, v2::Vector{ComplexF64}) :: Float64\n\nCompute the fidelity between two complex vectors v1 and v2.\n\nThe fidelity is defined as the squared absolute value of the dot product between v1 and v2.\n\nArguments\n\nv1::Vector{ComplexF64}: The first complex vector.\nv2::Vector{ComplexF64}: The second complex vector.\n\nReturns\n\nFloat64: The fidelity between v1 and v2.\n\n\n\n\n\n","category":"function"},{"location":"man/circuitUtils/","page":"Circuit Utilities","title":"Circuit Utilities","text":"fidelity(u, d)","category":"page"},{"location":"man/circuitUtils/","page":"Circuit Utilities","title":"Circuit Utilities","text":"warning: Fidelity over loaded\nThe fidelity function is defined in the QuantumInformation module as well, so you may need to use the full path to the function.QuantumCircuits.fidelity(u, d)","category":"page"},{"location":"man/circuitUtils/#Probability","page":"Circuit Utilities","title":"Probability","text":"","category":"section"},{"location":"man/circuitUtils/","page":"Circuit Utilities","title":"Circuit Utilities","text":"tip: Probability\nThe probability of measuring a state in a given basis is the square of the amplitude of the state in that basis.P(psi Pi) = langle psi  Pi  psi rangle","category":"page"},{"location":"man/circuitUtils/","page":"Circuit Utilities","title":"Circuit Utilities","text":"prob","category":"page"},{"location":"man/circuitUtils/#QuantumCircuits.prob","page":"Circuit Utilities","title":"QuantumCircuits.prob","text":"prob(state::Vector{ComplexF64}, Π::Matrix{ComplexF64})::Float64\n\nCompute the probability of measuring a quantum state state given the measurement operator Π.\n\nArguments\n\nstate::Vector{ComplexF64}: The quantum state vector.\nΠ::Matrix{ComplexF64}: The measurement operator.\n\nReturns\n\nFloat64: The probability of measuring the state.\n\n\n\n\n\n","category":"function"},{"location":"man/circuitUtils/","page":"Circuit Utilities","title":"Circuit Utilities","text":"Pi = u * u';\nprob(u, Pi)","category":"page"},{"location":"man/circuitUtils/#Measurement","page":"Circuit Utilities","title":"Measurement","text":"","category":"section"},{"location":"man/circuitUtils/","page":"Circuit Utilities","title":"Circuit Utilities","text":"projective_measurement_operator","category":"page"},{"location":"man/circuitUtils/#QuantumCircuits.projective_measurement_operator","page":"Circuit Utilities","title":"QuantumCircuits.projective_measurement_operator","text":"projective_measurement_operator(n::Int, basis::Char, index::Int)::Matrix{ComplexF64}\n\nConstructs the projective measurement operator for a quantum circuit.\n\nArguments\n\nn::Int: The number of qubits in the quantum circuit.\nbasis::Char: The measurement basis. Must be either 'z' or 'x'.\nindex::Int: The index of the qubit to be measured.\n\nReturns\n\nA matrix representing the projective measurement operator.\n\n\n\n\n\n","category":"function"},{"location":"man/circuitUtils/","page":"Circuit Utilities","title":"Circuit Utilities","text":"post_measurement_state","category":"page"},{"location":"man/circuitUtils/#QuantumCircuits.post_measurement_state","page":"Circuit Utilities","title":"QuantumCircuits.post_measurement_state","text":"post_measurement_state(state::Vector{ComplexF64}, Π::Matrix{ComplexF64})::Vector{ComplexF64}\n\nPost-processes the state vector after a measurement is performed.\n\nArguments\n\nstate::Vector{ComplexF64}: The input state vector.\nΠ::Matrix{ComplexF64}: The measurement operator.\n\nReturns\n\nVector{ComplexF64}: The post-measurement state vector.\n\nThrows\n\nArgumentError: If the probability of getting the measurement outcome is zero.\n\n\n\n\n\n","category":"function"},{"location":"man/circuitEvolve/#Quantum-Circuit-Time-Evolution","page":"Circuit Evolution","title":"Quantum Circuit Time Evolution","text":"","category":"section"},{"location":"#QuantumCircuits","page":"Home","title":"QuantumCircuits","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"warning: Disclaimer\nI want to clarify that this package is not a wrapper around any quantum computing library. It is a standalone package that uses classical computation (Linear Algebra) to simulate quantum circuits. More about the mathematics behind the quantum circuits can be found in the Theory section.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumCircuits package was developed alongside my NIUS Project. This package mainly deals with the classical \"Random Quantum Circuit simulation.\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is heavily inspired by the QuantumInformation.jl package. The main difference between the two is that QuantumCircuits is more focused on the simulation of quantum circuits. At the same time, QuantumInformation is more focused on the mathematical aspects of quantum information theory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the time being, this package contains the following features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Random Matrices\nHere, you can generate the following random matrices:\nRandom Unitary\nRandom Hermitian\nCircuit Utilities\nHere, you can find the following utilities:\nRandom State vector\nZero State vector for a given number of qubits\nCheck if a given state vector is a valid state vector\nFidelity between two state vectors\nProbability of measuring a state vector on a given basis\nState vector after a projective measurement\nCreates a measurement operator for a given basis for a given qubit in a system\nCircuit Evolution","category":"page"},{"location":"#Theory","page":"Home","title":"Theory","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"tip: Before Read\nI would assume that you have some basic knowledge of quantum computing. If you don't, I would recommend you to go through the bible of quantum computing, Quantum Computation and Quantum Information by Michael A. Nielsen and Isaac L. Chuang.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To discuss how we simulate Quantum Circuit, lets discuss the mathematics with the example of Bell State. Using the standard convention set by Qiskit, lets initialize our quantum circuit composed of two qubits in state 00rangle. Using following circuit we can create a Bell state from the initial state","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Bell Circuit)","category":"page"},{"location":"","page":"Home","title":"Home","text":"So using basic linear algebra representation, we can write,","category":"page"},{"location":"","page":"Home","title":"Home","text":"0rangle = beginbmatrix 1  0 endbmatrix quad implies quad 00rangle = beginbmatrix 1  0 endbmatrix otimes beginbmatrix 1  0 endbmatrix","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, we can simulate this circuit by representing this circuit as a unitary matrix, say Psirangle is the final state of the circuit i.e.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Psirangle = CXH otimes I00rangle","category":"page"},{"location":"","page":"Home","title":"Home","text":"where CX is the matrix representation of Controlled NOT Gate, and H is the matrix representation of Hadamard Gate.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In general, these matrices can be combined into a single unitary matrix say mathcalU, and say our initial state is given by Psirangle, so after the evolution we have the final state Phirangle, as","category":"page"},{"location":"","page":"Home","title":"Home","text":"Phirangle = mathcalU  Psirangle","category":"page"},{"location":"#Magic-of-Measurements","page":"Home","title":"Magic of Measurements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We can use similar strategy to simulate projective measurements as well. Say we have a projection operator Pi, and we want to do a measurement on the state Psirangle, so the state after the measurement can be calculated by,","category":"page"},{"location":"","page":"Home","title":"Home","text":"Phirangle = frac Pi Psirangle  langle Psi  Pi  Psi rangle ","category":"page"},{"location":"#Future-Plans","page":"Home","title":"Future Plans","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I needed only a few features since I developed this package for my research. I will be adding more features in the future.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Things to remember\nI will add more features in the future.","category":"page"},{"location":"#Special-Thanks","page":"Home","title":"Special Thanks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I want to thank my mentor, Dr. Sambuddha Sanyal, for guiding me throughout the project. I would also like to thank HBCSE for providing me with this opportunity.","category":"page"}]
}
